defmodule ExOauth2Provider.AccessGrants.AccessGrantTest do
  use ExOauth2Provider.TestCase

  alias Dummy.OauthAccessGrants.OauthAccessGrant
  alias Dummy.Repo
  alias Ecto.Changeset
  alias ExOauth2Provider.AccessGrants.AccessGrant
  alias ExOauth2Provider.Test.Fixtures
  alias ExOauth2Provider.Test.PKCE

  describe "changeset/3" do
    test "returns a valid changeset with a token and the default app scope when the attrs are valid" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:ok, %OauthAccessGrant{} = grant} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert grant.application == app
      assert grant.expires_in == attrs.expires_in
      assert grant.redirect_uri == attrs.redirect_uri
      assert grant.resource_owner == user
      assert grant.scopes == "public"
      assert is_binary(grant.token)
    end

    test "requires expires_in to be an integer" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()

      attrs = %{
        expires_in: "900",
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:ok, %OauthAccessGrant{} = grant} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert grant.expires_in == 900

      attrs = %{
        expires_in: "nine-hundred-seconds",
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert {"is invalid", _} = errors[:expires_in]
    end

    test "requires redirect_uri to be a string" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()

      attrs = %{
        expires_in: 900,
        redirect_uri: nil
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert {"can't be blank", _} = errors[:redirect_uri]

      attrs = %{
        expires_in: 900,
        redirect_uri: ""
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert {"can't be blank", _} = errors[:redirect_uri]

      attrs = %{
        expires_in: 900,
        redirect_uri: :something
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert {"is invalid", _} = errors[:redirect_uri]
    end

    test "requires token to be a unique string" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()
      grant = Fixtures.access_grant(app, user, "ima-token", "redirect-uri")

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      # Token is generated by the code and is not castable. Let's force it.
      assert {:error, %Changeset{errors: errors}} =
               AccessGrant.changeset(
                 %OauthAccessGrant{
                   application: app,
                   resource_owner: user
                 },
                 attrs,
                 otp_app: :ex_oauth2_provider
               )
               |> Changeset.put_change(:token, grant.token)
               |> Repo.insert()

      assert {"has already been taken", _} = errors[:token]
    end

    test "accepts scopes and requires them to be permitted by the application" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob",
        scopes: "read write"
      }

      assert {:ok, %OauthAccessGrant{} = grant} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert grant.scopes == "read write"

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob",
        scopes: "foo"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider)
               |> Changeset.apply_action(:validate)

      assert {~s(not in permitted scopes list: "public read write"), _} = errors[:scopes]
    end
  end

  describe "changeset/2 when PKCE is required" do
    test "requires code_challenge and code_challenge_method when PKCE is required" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()

      attrs = %{
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider, use_pkce: true)
               |> Changeset.apply_action(:validate)

      assert {"can't be blank", _} = errors[:code_challenge]
      assert {"can't be blank", _} = errors[:code_challenge_method]
    end

    test "accepts all supported challenge methods" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()
      challenge = PKCE.generate_code_challenge()

      for {method, query_param} <- [{:plain, "plain"}, {:s256, "S256"}] do
        attrs = %{
          code_challenge: challenge,
          code_challenge_method: query_param,
          expires_in: 900,
          redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
        }

        assert {:ok, %OauthAccessGrant{} = grant} =
                 %OauthAccessGrant{
                   application: app,
                   resource_owner: user
                 }
                 |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider, use_pkce: true)
                 |> Changeset.apply_action(:validate)

        assert grant.code_challenge == challenge
        assert grant.code_challenge_method == method
      end
    end

    test "rejects unsupported challenge methods" do
      app = Fixtures.application()
      user = Fixtures.resource_owner()

      attrs = %{
        code_challenge: PKCE.generate_code_challenge(),
        code_challenge_method: "not-a-real-method",
        expires_in: 900,
        redirect_uri: "urn:ietf:wg:oauth:2.0:oob"
      }

      assert {:error, %Changeset{errors: errors}} =
               %OauthAccessGrant{
                 application: app,
                 resource_owner: user
               }
               |> AccessGrant.changeset(attrs, otp_app: :ex_oauth2_provider, use_pkce: true)
               |> Changeset.apply_action(:validate)

      refute Keyword.has_key?(errors, :code_challenge)
      assert {"is invalid", _} = errors[:code_challenge_method]
    end
  end
end
